<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>JavaScriptの基本 — 現場で使える最初の一歩</title>
  <link rel="stylesheet" href="/assets/styles.css?v=1766977946166">
</head>
<body>
  <main class="container">
    <article class="card">
      <header>
        <h1>JavaScriptの基本 — 現場で使える最初の一歩</h1>
        <nav><a href="/index.html">Home</a></nav>
        <p class="meta">投稿日：2025-12-26</p>
      </header>

      <section id="sec-toc">
        <h2>目次</h2>
        <ul>
  <li><a href="#sec-1">はじめに</a></li>
  <li><a href="#sec-2">開発環境の準備（ブラウザとNode.js）</a></li>
  <li><a href="#sec-3">変数とデータ型（var/let/const・型の変換）</a></li>
  <li><a href="#sec-4">制御構文とよく使うメソッド（if/for/Arrayメソッド）</a></li>
  <li><a href="#sec-5">関数・スコープ・クロージャの実務ポイント</a></li>
  <li><a href="#sec-6">オブジェクトと配列の扱い（破壊的操作と不変性）</a></li>
  <li><a href="#sec-7">DOM操作とイベント（現場でよく使うパターン）</a></li>
</ul>
      </section>

      <section id="sec-1">
        <h3>はじめに</h3>
        <p>この文書はIT初心者が「現場で使える」JavaScriptの最初の一歩を踏み出すための実践ガイドです。具体例を多く示し、よくある失敗と現場での判断ポイントに重点を置いています。</p>
      </section>

<section id="sec-2">
        <h3>開発環境の準備（ブラウザとNode.js）</h3>
        <ul>
  <li>ブラウザ：Chrome（DevToolsが充実）。Firefoxも検証に便利。</li>
  <li>Node.js：LTS版をインストール。npmまたはpnpmでパッケージ管理。</li>
  <li>エディタ：VS Code（拡張機能：ESLint, Prettier, Live Server）</li>
  <li>開発サーバー：ローカルで静的ファイル確認は Live Server や <code>http-server</code> を利用。</li>
</ul>

<p>例：簡単なローカルサーバ起動（npm）</p>
<pre><code class="language-bash">npm install -g http-server
http-server ./public -p 8080
</code></pre>

<p><strong>注意：</strong><code>npm install -g</code> はグローバル環境にインストールします。社内PCや権限が厳しい環境では運用ルールに従い、問題がある場合はプロジェクトローカル（<code>npm install --save-dev</code> 等）での導入を検討してください。</p>
      </section>

<section id="sec-3">
        <h3>変数とデータ型（var/let/const・型の変換）</h3>
        <ul>
  <li><code>var</code>：関数スコープ。ホイスティングと意図しない再宣言の原因になるため現場では非推奨。</li>
  <li><code>let</code>：ブロックスコープ、再代入可。</li>
  <li><code>const</code>：ブロックスコープ、再代入不可（参照先のオブジェクトは変更可能）。</li>
</ul>

<p>例：</p>
<pre><code>const PI = 3.14; // 定数
let count = 0;   // 状態を持つ変数
// var old = '使わないで';</code></pre>

<p>型変換：</p>
<ul>
  <li><code>Number("123")</code> -&gt; <code>123</code>、<code>parseInt</code>/<code>parseFloat</code> の違い（<code>parseInt</code> は第二引数で基数指定）</li>
  <li><code>String(123)</code> またはテンプレートリテラル <code>${value}</code></li>
</ul>

<p>注意：<code>==</code> と <code>===</code></p>
<ul>
  <li><code>==</code> は型変換して比較（例：<code>"0" == 0</code> は <code>true</code>）</li>
  <li><code>===</code> は厳密比較。現場では <code>===</code> を推奨。</li>
</ul>
      </section>

<section id="sec-4">
        <h3>制御構文とよく使うメソッド（if/for/Arrayメソッド）</h3>
        <p>制御構文の基本（読み書きできると現場で困りません）：</p>
<pre><code class="language-js">if (condition) { ... } else { ... }
for (let i=0;i&lt;array.length;i++) { ... }
for (const item of array) { ... }</code></pre>

<p>配列メソッド（現場で頻出）：</p>
<ul>
  <li><code>map</code>: 元配列を変換して新配列を返す</li>
  <li><code>filter</code>: 条件に合う要素を抽出して新配列を返す</li>
  <li><code>reduce</code>: 集約処理（合計・連結・オブジェクト化など）</li>
  <li><code>find</code>: 条件に合う最初の要素を返す（なければ <code>undefined</code>）</li>
  <li><code>forEach</code>: 各要素に対して処理する（戻り値は使わない／副作用向け）</li>
</ul>

<p>例：</p>
<pre><code class="language-js">const nums = [1,2,3,4];
const squares = nums.map(n =&gt; n*n); // [1,4,9,16]
const evens = nums.filter(n =&gt; n%2===0); // [2,4]
const sum = nums.reduce((acc,n)=&gt;acc+n, 0); // 10</code></pre>

<p><code>reduce</code> の初期値（第2引数）の注意：</p>
<ul>
  <li>初期値を省略すると「配列の最初の要素」が初期値扱いになるため、空配列だと例外になります。</li>
</ul>

<p><strong>注意（よくある失敗）:</strong> <code>forEach</code> のコールバック内で <code>await</code> しても、ループ全体は待ってくれません。非同期で順に処理したい場合は <code>for..of</code> と <code>await</code> を使います。</p>
      </section>

<section id="sec-5">
        <h3>関数・スコープ・クロージャの実務ポイント</h3>
        <ul>
  <li>関数宣言・関数式・アロー関数は書き方だけでなく挙動も異なります。特にアロー関数は <code>this</code> を自分で持たず、外側の <code>this</code> をそのまま参照します（メソッドやイベントハンドラでの意図しない <code>this</code> ずれに注意）。</li>
  <li>クロージャは「外側の変数を覚えている関数」です。イベントハンドラや factory パターンで、状態を安全に閉じ込めたいときに有用です。</li>
</ul>

<p>例（クロージャ）：</p>
<pre><code>function makeCounter() {
  let count = 0;
  return function() {
    count += 1;
    return count;
  };
}
const c = makeCounter();
c(); // 1
</code></pre>

<p>よくある失敗：ループ内で <code>var</code> を使うと、クロージャが「最後の値」を参照してしまうことがあります。回避法は次のとおりです。</p>
<ul>
  <li><code>let</code> を使って、反復ごとに別の束縛を作る</li>
  <li>即時関数（IIFE）で値をキャプチャする</li>
</ul>
      </section>

<section id="sec-6">
        <h3>オブジェクトと配列の扱い（破壊的操作と不変性）</h3>
        <ul>
  <li>オブジェクトのコピー：スプレッド演算子 <code>{...obj}</code>、<code>Object.assign({}, obj)</code></li>
  <li>配列の変更：<code>push</code>/<code>pop</code> は破壊的、<code>concat</code>/<code>map</code>/<code>filter</code> は非破壊的</li>
</ul>

<p><strong>注意（重要）:</strong> <strong>破壊的操作（ミューテーション）は元のデータを直接書き換える</strong>ため、状態の追跡が難しくなり、バグや意図しない副作用の原因になります。特にReduxなどの状態管理では<strong>不変性（イミュータブル）</strong>を前提にしているため、破壊的変更は避けてください。</p>

<ul>
  <li>破壊的な変更は状態管理を難しくし、差分検知やデバッグを壊しやすい</li>
  <li>DOM要素の <code>innerHTML</code> を直接上書きしたり、配列を直接 mutate する操作はバグの元になりやすい</li>
</ul>

<pre><code>const a = [1,2];
a.push(3); // 破壊的。元配列を変更
const b = a.concat(4); // 非破壊的。新しい配列 b を返す
</code></pre>
      </section>

<section id="sec-7">
        <h3>DOM操作とイベント（現場でよく使うパターン）</h3>
        <p>よく使うAPI：</p>
<ul>
  <li><code>document.querySelector</code> / <code>querySelectorAll</code></li>
  <li><code>element.addEventListener('click', handler, { once: true, passive: true })</code></li>
  <li><code>element.classList.add</code> / <code>remove</code> / <code>toggle</code></li>
  <li><code>fetch</code>でAPIを叩き、結果をDOMに描画</li>
</ul>

<p>例：クリックでボタンを無効化し、クリック回数を表示</p>
<pre><code>&lt;button id="btn"&gt;Click&lt;/button&gt;
&lt;span id="count"&gt;0&lt;/span&gt;
&lt;script&gt;
const btn = document.querySelector('#btn');
const span = document.querySelector('#count');
let cnt = 0;
btn.addEventListener('click', () =&gt; {
  cnt++;
  span.textContent = cnt;
  if (cnt &gt;= 5) btn.disabled = true;
});
&lt;/script&gt;</code></pre>

<p>イベントオプションの意味：</p>
<ul>
  <li><code>capture</code>: イベントの伝播フェーズを切り替える（<code>true</code>でキャプチャリング＝親→子、<code>false</code>でバブリング＝子→親）</li>
  <li><code>once</code>: 最初の1回だけ実行して自動的に解除する</li>
  <li><code>passive</code>: リスナー内で<code>preventDefault()</code>しないことを宣言し、スクロールなどのパフォーマンス改善に寄与（必要な場合は<code>false</code>に）</li>
</ul>
      </section>

      
    </article>
  </main>
</body>
</html>