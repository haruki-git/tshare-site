<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>JavaScript：値と型（バグを減らす型感覚）</title>
  <link rel="stylesheet" href="/assets/styles.css?v=1767406624605">
</head>
<body>
  <main class="container">
    <article class="card">
      <header>
        <h1>JavaScript：値と型（バグを減らす型感覚）</h1>
        <nav><a href="/posts/JavaScript/">JavaScript記事一覧</a></nav>
        <p class="meta">投稿日：2026-01-13</p>
      </header>

      <section class="card" style="margin-top:12px;">
        <h2 style="margin:0 0 8px 0;">音声</h2>
        <audio controls preload="none" src="/posts/genba/audio/301.mp3"></audio>
        <p class="meta" style="margin-top:8px; opacity:0.85;">※ AI音声で読み上げます</p>
      </section>

      

      <section id="sec-toc">
        <h2>目次</h2>
        <ol>
  <li><a href="#sec-1">number / string / boolean / null / undefined</a></li>
  <li><a href="#sec-2">等価比較：== と === の違い</a></li>
  <li><a href="#sec-3">暗黙の型変換で起きる事故例</a></li>
  <li><a href="#sec-4">NaNとInfinityの扱い</a></li>
  <li><a href="#sec-5">型を確認する（typeofの基本）</a></li>
  <li><a href="#sec-6">注意（ここだけ）</a></li>
  <li><a href="#sec-7">要約</a></li>
</ol>
      </section>

<section id="sec-1">
  <h3>number / string / boolean / null / undefined</h3>

  <p>基本的な値の種類を見分けて、型による振る舞いの違いでバグを減らせるようにしましょう。</p>
  <p>number（数値）は計算に使い、string（文字列）はテキスト、boolean（真偽）は条件分岐に使います。</p>
  <p>nullは「値がないことを明示」し、undefinedは「値が未定義または未設定」を表します。これらが混ざると思わぬ挙動になるため、使い分けが重要です。</p>

  <p>
    この最小例は、ボタンを押すと <code>typeof</code> の結果をまとめて表示し、
    「数値のゼロ」と「文字列のゼロ」が別物であること、<code>null</code> と <code>undefined</code> の違いを目で確認できるようにするデモです。
  </p>

  <p>貼り付け場所：CodePenを想定する場合はHTML欄とJS欄に分けて貼り付けます。HTML欄にはボタンと出力要素（例：#check, #result）を用意します。</p>

  <pre><code class="language-html">&lt;!-- HTML欄（CodePenのHTMLエリアに貼ってください） --&gt;
&lt;button id="check"&gt;型チェック実行&lt;/button&gt;
&lt;div id="result"&gt;&lt;/div&gt;
</code></pre>

  <p>最小コード：</p>

  <pre><code class="language-javascript">// JS欄（CodePenのJSエリアに貼ってください）
const out = document.getElementById('result');
document.getElementById('check').addEventListener('click', () =&gt; {
  const a = 0;           // number
  const b = "0";         // string
  const c = null;        // null
  const d = undefined;   // undefined
  out.innerText = [
    `a:${a} (${typeof a})`,
    `b:${b} (${typeof b})`,
    `c:${c} (${typeof c})`,
    `d:${d} (${typeof d})`,
  ].join('\n');
});
</code></pre>

  <p>確認方法：ボタンを押して、表示が次のようになればOKです。特に <code>null</code> が <code>object</code> と表示される点は、JavaScriptの仕様として覚えておくと混乱が減ります。</p>
  <p>実行結果：</p>

  <pre><code>a:0 (number)
b:0 (string)
c:null (object)
d:undefined (undefined)</code></pre>

  <p>
    結果の説明：<br>
    1つ目。<code>a</code> は数値のゼロなので、<code>typeof a</code> は <code>number</code> になります。数値は足し算などの計算に使われます。<br>
    2つ目。<code>b</code> は文字列のゼロなので、<code>typeof b</code> は <code>string</code> になります。見た目が同じ「0」でも、文字列は計算ではなくテキストとして扱われます。<br>
    3つ目。<code>c</code> は <code>null</code> なので、本来は「値がないことを明示」という意味です。ただしJavaScriptの歴史的な理由で、<code>typeof null</code> は <code>object</code> と表示されます（これは例外として覚えておくのが安全です）。<br>
    4つ目。<code>d</code> は <code>undefined</code> なので、<code>typeof d</code> は <code>undefined</code> になります。これは「値が未設定・未定義」の状態を表します。<br>
    まとめると、<strong>見た目が似ていても型が違うと扱いが変わる</strong>ので、<code>typeof</code> で確認できるようにしておくとバグを減らせます。
  </p>

</section>

<section id="sec-2">
  <h3>等価比較：== と === の違い</h3>
  <p>==（ダブルイコール）は型変換を行った上で比較し、===（トリプルイコール）は型も値も同じ場合にのみ真になります。</p>
<p>例えば 0 == "0" は真になりますが、0 === "0" は偽になります。</p>
<p>条件分岐では型の違いで誤判定しやすいため、原則 === を使うことで予測可能性が高まります。</p>
<p>既存コードで意図的な型変換がある場合に限り == を選ぶ判断が必要です。</p>
</section>

<section id="sec-3">
  <h3>暗黙の型変換で起きる事故例</h3>
  <p>暗黙の型変換（coercion）は便利ですが、意図しない結果を生みます。</p>

  <p>例：プラスは「文字列連結」になりやすく、マイナスは「数値計算」になりやすいです。</p>
  <pre><code class="language-javascript">"" + 1   // "1"
"" - 1   // -1</code></pre>

  <p>また、直感に反する比較が起こることがあります。</p>
  <pre><code class="language-javascript">[] == 0  // true</code></pre>

  <p>文字列連結や数値計算を行うときは、明示的な変換（<code>Number()</code> / <code>String()</code>）を使うと事故が減ります。</p>

  <p>明示的な変換の例：</p>
  <pre><code class="language-javascript">// 数値にする
Number("10")      // 10
Number("")        // 0
Number("abc")     // NaN（数値にできない）

// 文字列にする
String(10)        // "10"
String(null)      // "null"</code></pre>

  <p>よくある安全な書き方（足し算を必ず数値にする）：</p>
  <pre><code class="language-javascript">const a = "10";
const b = "2";
const sum = Number(a) + Number(b); // 12</code></pre>

  <p>入力値（フォームなど）は基本文字列なので、計算前に数値へ変換し、必要なら <code>Number.isNaN()</code> でチェックします。</p>
</section>

<section id="sec-4">
  <h3>NaNとInfinityの扱い</h3>
  <p>
    計算で想定外の値になることがあります。0/0 は NaN（Not-a-Number）になり、1/0 は Infinity になります。
    NaN は自分自身とも等しくない特徴があり、NaN === NaN は偽です。
    isNaN() や Number.isNaN()、Number.isFinite() を使って検査し、無効な計算結果を早めに処理すると安全性が高まります。
  </p>

  <p>最小の実例：</p>
  <pre><code class="language-javascript">const x = 0 / 0;   // NaN
const y = 1 / 0;   // Infinity
const z = Number("abc"); // NaN

// isNaN は「数値に変換してから」判定するので、文字列でも true になり得る
console.log(isNaN("abc"));          // true

// Number.isNaN は「本当に NaN か」だけを見る（より安全）
console.log(Number.isNaN(z));       // true
console.log(Number.isNaN("abc"));   // false

// 有限かどうか（NaN と Infinity をまとめて弾ける）
console.log(Number.isFinite(x));    // false
console.log(Number.isFinite(y));    // false
console.log(Number.isFinite(123));  // true

// 無効な計算結果を早めに処理する例
function safeDiv(a, b) {
  const r = a / b;
  if (!Number.isFinite(r)) return 0; // NaN / Infinity をまとめて回避
  return r;
}

console.log(safeDiv(10, 2)); // 5
console.log(safeDiv(1, 0));  // 0
console.log(safeDiv(0, 0));  // 0</code></pre>
</section>

<section id="sec-5">
  <h3>型を確認する（typeofの基本）</h3>

  <p>
    目次 1 では「型の違いを目で確認する」体験をしました。ここでは実務で使うために、
    <code>typeof</code> を「いつ」「どう使うか」と、例外（null・配列）だけ押さえます。
  </p>

  <p><strong>基本：</strong>値が何っぽいかを手早く知りたいときに <code>typeof</code> を使います。</p>
  <pre><code class="language-javascript">typeof 123    // "number"
typeof "a"    // "string"
typeof true   // "boolean"
typeof undefined // "undefined"</code></pre>

  <p>
    <strong>注意1（null）：</strong><code>typeof null</code> は歴史的事情で <code>"object"</code> になります。
    なので null 判定は <code>x === null</code> のように値比較で行うのが確実です。
  </p>
  <pre><code class="language-javascript">const x = null;
console.log(typeof x);     // "object"（例外）
console.log(x === null);   // true（これが確実）</code></pre>

  <p>
    <strong>注意2（配列）：</strong>配列も <code>typeof</code> だと <code>"object"</code> になります。
    配列かどうかは <code>Array.isArray()</code> を使います。
  </p>
  <pre><code class="language-javascript">const a = [1, 2, 3];
console.log(typeof a);          // "object"
console.log(Array.isArray(a));  // true</code></pre>

  <p>
    <strong>よくある使い方：</strong>関数の引数が想定どおりかを早めにチェックして、変な値なら止めます。
    これだけで「後半で謎のエラーになる」事故が減ります。
  </p>
  <pre><code class="language-javascript">function addSafe(n) {
  if (typeof n !== "number") return 0; // 早めに回避
  return n + 1;
}

console.log(addSafe(10));   // 11
console.log(addSafe("10")); // 0</code></pre>

  <p>実行方法：ブラウザで開くか、CodePenのRunで実行します。Consoleで結果を見ます。</p>
  <p>確認方法：console.logの出力が想定どおりかを確認します。</p>

  <p>よくあるミス：Consoleを開いていないため出力が見えない、または変数名のスペル違いでReferenceErrorになることがあります。</p>
</section>


<section id="sec-6">
  <h3>注意（ここだけ）</h3>
  <ul>
    <li><p><code>typeof null</code> は歴史的事情で <code>"object"</code> になります（null判定は <code>value === null</code> を使います）。</p></li>
    <li><p><code>NaN</code> は「自分自身とも等しくない」ので <code>value === NaN</code> は常にfalseです。判定は <code>Number.isNaN(value)</code> を使います。</p></li>
    <li><p>小数は誤差が出ます（例：<code>0.1 + 0.2 !== 0.3</code>）。金額などは「整数（円・最小単位）」で扱うのが安全です。</p></li>
  </ul>
</section>

      <section id="sec-7">
  <h3>要約</h3>
  <ul>
  <li>number/string/boolean/null/undefined は用途ごとに使い分けるとバグが減ります。</li>
  <li>=== は型も比較するため予測可能で、原則こちらを使います。</li>
  <li>暗黙の型変換は直感と異なる結果を生むため明示変換を検討します。</li>
  <li>NaN は自分自身と等しくないため Number.isNaN での検査が有効です。</li>
  <li>typeof は基本を押さえつつ null や配列の扱いを補助関数で補うと安全です。</li>
</ul>
</section>
    </article>
  </main>
</body>
</html>